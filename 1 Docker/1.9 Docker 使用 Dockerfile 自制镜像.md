# 1.8 Docker 使用 Dockerfile 自制镜像

我们之前使用过 `docker commit` 来自制镜像，但为什么不要使用 `docker commit` 而是使用 Dockerfile 来自制进行呢？

首先，观察之前 `docker container diff` 命令输出的结果：

```bash
$ docker container diff nginx
C /usr
C /usr/share
C /usr/share/nginx
C /usr/share/nginx/html
C /usr/share/nginx/html/index.html
C /root
A /root/.bash_history
C /var
C /var/cache
C /var/cache/nginx
A /var/cache/nginx/client_temp
A /var/cache/nginx/fastcgi_temp
A /var/cache/nginx/proxy_temp
A /var/cache/nginx/scgi_temp
A /var/cache/nginx/uwsgi_temp
C /run
A /run/nginx.pid
```

发现除了真正想要修改的 `/usr/share/nginx/html/index.html` 文件除外，还有很多文件被添加或者修改了，比如说缓存文件、Pid 文件等等。这还只是最简单的操作，如果是安装软件包、编译构建，那会有大量无关的内容被添加进来，如果不注意清理，将会导致镜像很臃肿。

此外，使用 `docker commit` 自制镜像，意味着所有对镜像的操作都是黑箱操作：

```bash
$ docker image history jugggao/nginx:1.0
IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT
62f1198899f3        About a minute ago   nginx -g daemon off;                            92B                 修改默认首页
...
```

并不能看到实际执行的命令，这种镜像也被称为**黑箱镜像**。就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像（说不定还忘了），别人根本无从得知。所以维护黑箱镜像的工作是很痛苦的。

而且，之前介绍过镜像是分层存储的。除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 `docker commit` 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。

所以，我们需要把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。

Dockerfile 是一个文本文件，期内包含了一条条**指令**，**每一条指令构建一层镜像层**，因此每一条指令的内容，就是描述该层应当如何构建。

比如我们最多使用的自制镜像：

在一个空白目录，新建一个文本文件，名为 Dockerfile。Dockerfile 内容如下：

```bash
FROM java:8

COPY demo-0.0.1.jar /demo-0.0.1.jar

ENTRYPOINT ["java","-jar","/demo-0.0.1.jar"]
```

然后我们就可以使用 `docker image build` 命令来构建镜像了：

```bash
$ tree
.
├── demo-0.0.1.jar
└── Dockerfile

0 directories, 2 files

$ docker image build -t java-demo:0.1 .
Sending build context to Docker daemon  16.72MB
Step 1/3 : FROM java:8
 ---> 719e41f3e37b
Step 2/3 : ADD demo-0.0.1.jar /demo-0.0.1.jar
 ---> Using cache
 ---> 243662a30000
Step 3/3 : ENTRYPOINT ["java","-jar","/demo-0.0.1.jar"]
 ---> Using cache
 ---> 328d450440c1
Successfully built 328d450440c1
Successfully tagged java-demo:0.1
```

这个 Dockerfile 很简单，一共用到了 3 个指令：`FROM`、`ADD` 和 `ENTRYPOINT`。

我们接下来分别介绍 Dockerfile 的常用指令。

## FROM 指定基础镜像

所谓定制镜像，一定是以一个镜像为基础，在其上进行定制（添加镜像层）。

我们之前做容器健康检查时发现 Nginx 容器中没有 `curl` 命令，所需需要在其基础上添加 `curl` 工具：

```Dockerfile
FROM nginx:1.14.2

RUN apt-get update -y && apt-get install -y curl
```

`FROM` 指令就是指定基础镜像，因此一个 Dockerfile 中 `FROM` 是必备的指令，并且必须是第一个。

在 [Docker Hub](https://hub.docker.com/) 上有很多质量非常高的官方镜像：

- 有可以直接拿来使用的服务类镜像：[Nginx](https://hub.docker.com/_/nginx)、[Tomcat](https://hub.docker.com/_/tomcat/)、[Php](https://hub.docker.com/_/php/)、[Httpd](https://hub.docker.com/_/httpd/)、[Wordpress](https://hub.docker.com/_/wordpress)、[Server JRE](https://hub.docker.com/_/oracle-serverjre-8)、[MySQL](https://hub.docker.com/_/mysql)、[Redis](https://hub.docker.com/_/redis)、[MongoDB](https://hub.docker.com/_/mongo) 等；

- 还有一些方便开发、构建、运行各种语言应用的镜像：[Node](https://hub.docker.com/_/node)、[Openjdk](https://hub.docker.com/_/openjdk)、[Python](https://hub.docker.com/_/python)、[Golang](https://hub.docker.com/_/golang)、[Ruby](https://hub.docker.com/_/ruby) 等；

- 如果没有找到对应的服务镜像，官方还提供了一些更为基础的操作系统镜像：[Ubuntu](https://hub.docker.com/_/ubuntu/)、[Debian](https://hub.docker.com/_/debian/)、[CentOS](https://hub.docker.com/_/centos/)、[Fedora](https://hub.docker.com/_/fedora/)、[Alpine](https://hub.docker.com/_/alpine/) 等。

- 甚至还有官方提供的空白镜像 [scratch](https://hub.docker.com/_/scratch)，这个镜像是虚拟的概念，它并不实际存在。如果你以 `scratch` 为基础镜像的话，意味着你不以任何镜像为基础，接下来的所写的指令将作为镜像第一层开始存在。<br/>对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。

对于使用官方镜像，必须要阅读官方镜像的说明，或者直接阅读官方镜像的 Dockerfile 能有助于我们更好的使用官方镜像。

比如说 MySQL 官方镜像提供了一些变量可以方便我们配置 MySQL 的 Root 密码：

> MYSQL_ROOT_PASSWORD
>
> This variable is mandatory and specifies the password that will be set for the MySQL root superuser account. In the above example, it was set to my-secret-pw.
> 
> ...

还告诉我们了 MySQL 数据存储的位置让我们能快速定位并使用数据卷或挂载数据目录：

> The -v /my/own/datadir:/var/lib/mysql part of the command mounts the /my/own/datadir directory from the underlying host system as /var/lib/mysql inside the container, where MySQL by default will write its data files.

并且告诉我们如何使用自定义文件、如何备份数据库等等。

官方镜像之所以质量高，其一是因为官方镜像很精简；其二是因为官方镜像会考虑到各种各样的情况来制定逻辑关系。所以我们使用官方镜像时一定要阅读官方镜像的说明，避免重复造轮子。


## RUN 执行命令

`RUN` 指令就是用来执行命令的。其格式有两种：

- Shell 格式：`RUN <命令>`，就像直接在命令行中输入的命令一样。我们制作镜像时通常会采用这种形式：

  ```Dockerfile
  FROM nginx:1.14.2

  RUN apt-get update -y && apt-get install -y curl
  ```

- Exec 格式：`RUN ["可执行文件", "参数1", "参数2"]`，这更像是函数中调用的格式。

我们现在就可以在 Dockerfile 使用 `RUN` 从一个基础的操作系统镜像来制作一个带有 Redis 服务的镜像了：

```Dockerfile
FROM debian:stretch

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
```

这样制作出来的镜像是可以使用的，但是这种做法是很愚蠢的。

我们之前提到过镜像是分层的，最开始也提到了 Dockerfile 中每一个指令都会建立一层镜像层。所以每个 `RUN` 指令都会新建立一层镜像层。上面的这种写法，创建了 7 层镜像层，这样做是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多刚开始写 Dockerfile 的人常犯的一个错误。

因此上面的 Dockerfile 正确的写法应该是这样：

```Dockerfile
FROM debian:stretch

RUN buildDeps='gcc libc6-dev make wget' \
    && apt-get update \
# 安装依赖包
    && apt-get install -y $buildDeps \
# 下载 Redis 程序并进行解压编译安装
    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
    && mkdir -p /usr/src/redis \
    && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    && make -C /usr/src/redis \
    && make -C /usr/src/redis install \
# 安装完成后清理安装文件
    && rm -rf /var/lib/apt/lists/* \
    && rm redis.tar.gz \
    && rm -r /usr/src/redis \
    && apt-get purge -y --auto-remove $buildDeps
```

Dockerfile 支持 Shell 类的行尾添加 `\` 的命令行换行方式，以及行首 `#` 进行注释的格式。 `&&` 表示前面的命令执行成功后才会执行后面的命令，可以将多个命令串联起来（`||` 是将多个命令并联起来，表示前面的命令执行失败才会执行后面的命令）。这样良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易。

这样做还有以下好处：

1. 首先，之前所有的命令只有一个目的：就是编译、安装 Redis 可执行文件。因为没有必要建立很多层，只需要一层就足够。因此仅仅使用一个 `RUN` 指令来完成这部分所有的任务，将之前的 7 层简化为了 1 层。

2. 此外这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。很多人刚开始写 Dockerfile 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。

所以，我们在撰写 Dockerfile 的时候，要经常提醒自己，**这并不是在写 Shell 脚本，而是在定义每一层该如何构建**。

## COPY 复制文件或目录

`COPY` 指令将从构建上下文目录中的文件或目录复制到新的一层镜像层内的目标位置。和 `RUN` 指令一样，也有两种格式：

- Shell 格式： `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`；

- Exec 格式： `COPY [--chown=<user>:<group>] ["<源路径>",... "<目标路径>"]`。

比如我们之前制作的 Java Demo 镜像的 Dockerfile：

```Dockerfile
FROM java:8

COPY demo-0.0.1.jar /demo-0.0.1.jar

ENTRYPOINT ["java","-jar","/demo-0.0.1.jar"]
```

**<源路径>**可以是多个，甚至可以是通配符，其通配符规则要满足 Go 语言的 [filepath.Match](https://golang.org/pkg/path/filepath/#Match) 规则：

```Dockerfile
COPY hom* /mydir/
COPY hom?.txt /mydir/
```

**<目标路径>**可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。

此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。

在使用该指令的时候还可以加上 `--chown=<user>:<group>` 参数来改变文件或目录的所属用户及所属组。


## ADD 复杂化的复制文件或目录

`ADD` 指令和 `COPY` 的格式基本一致：

- Shell 格式： `ADD [--chown=<user>:<group>] <源路径>... <目标路径>`；

- Exec 格式： `ADD [--chown=<user>:<group>] ["<源路径>",... "<目标路径>"]`。

只是 `ADD` 指令在 `COPY` 指令基础上增加了一些功能：

- **好用的功能**：如果 `<源路径>` 为一个 tar 压缩文件的话，压缩格式为 `gzip`、`bzip2`以及 `xz` 的情况下，`ADD` 指令将会自动解压缩这么压缩文件到 `<目标路径>` 中。某些情况下，这个自动解压缩的功能非常好用，比如说 [CentOS 官方镜像](https://github.com/CentOS/sig-cloud-instance-images/blob/a77b36c6c55559b0db5bf9e74e61d32ea709a179/docker/Dockerfile)：

  ```bash
  FROM scratch
  ADD centos-7-docker.tar.xz /
  ...
  ```

  如果你不希望解压压缩包，就不要在 `<目标路径>` 的结尾加上 `/`，这样 Docker 会把 `<目标路径>` 当做一个文件。

  ```bash
  FROM java:8

  COPY demo-0.0.1.jar /demo-0.0.1.jar

  ENTRYPOINT ["java","-jar","/demo-0.0.1.jar"]  
  ```

- **不好用的功能**：如果 `<源路径>` 为一个 URL，Docker 引擎会试图下载这个 URL 连接的文件放到 `<目标路径>` 中。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，还需要增加额外的一层 `RUN` 进行权限调整；另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN` 指令进行解压缩。<br/>所以不如直接用 `RUN` 指令，然后使用 `wget` 或者 `curl` 工具下载、处理权限、解压缩，然后清理无用文件更合理。因此，这是个非常愚蠢的功能，不推荐使用。

总之，尽可能的使用 `COPY`，因为 `COPY` 的语义非常明确，只是复制文件或目录而已。而 `ADD`，包含了更复杂的功能，其行为不是很清晰。所以，只有在需要自动解压缩的情况下去使用 `ADD` 指令。


