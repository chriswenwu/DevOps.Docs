# 1.8 Docker 使用 Dockerfile 自制镜像

我们之前使用过 `docker commit` 来自制镜像，但为什么不要使用 `docker commit` 而是使用 Dockerfile 来自制进行呢？

首先，观察之前制作镜像时使用 `docker container diff` 命令输出的结果：

```bash
$ docker container diff nginx
C /usr
C /usr/share
C /usr/share/nginx
C /usr/share/nginx/html
C /usr/share/nginx/html/index.html
C /root
A /root/.bash_history
C /var
C /var/cache
C /var/cache/nginx
A /var/cache/nginx/client_temp
A /var/cache/nginx/fastcgi_temp
A /var/cache/nginx/proxy_temp
A /var/cache/nginx/scgi_temp
A /var/cache/nginx/uwsgi_temp
C /run
A /run/nginx.pid
```

发现除了真正想要修改的 `/usr/share/nginx/html/index.html` 文件除外，还有很多文件被添加或者修改了，比如说缓存文件、Pid 文件等等。这还只是最简单的操作，如果是安装软件包、编译构建，那会有大量无关的内容被添加进来，如果不注意清理，将会导致镜像很臃肿。

此外，使用 `docker commit` 自制镜像，意味着所有对镜像的操作都是黑箱操作：

```bash
$ docker image history jugggao/nginx:1.0
IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT
62f1198899f3        About a minute ago   nginx -g daemon off;                            92B                 修改默认首页
...
```

并不能看到实际执行的命令，这种镜像也被称为**黑箱镜像**。就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像（说不定还忘了），别人根本无从得知。所以维护黑箱镜像的工作是很痛苦的。

而且，之前介绍过镜像是分层存储的。除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 `docker commit` 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。

所以，我们需要把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。

Dockerfile 是一个文本文件，期内包含了一条条**指令**，**每一条指令构建一层镜像层**，因此每一条指令的内容，就是描述该层应当如何构建。

比如我们最多使用的自制镜像：

在一个空白目录，新建一个文本文件，名为 Dockerfile。Dockerfile 内容如下：

```bash
FROM java:8

COPY demo-0.0.1.jar /demo-0.0.1.jar

CMD ["java","-jar","/demo-0.0.1.jar"]
```

然后我们就可以使用 `docker image build` 命令来构建镜像了：

```bash
$ tree
.
├── demo-0.0.1.jar
└── Dockerfile

0 directories, 2 files

$ docker image build -t java-demo:0.1 .
Sending build context to Docker daemon  16.72MB
Step 1/3 : FROM java:8
 ---> 719e41f3e37b
Step 2/3 : ADD demo-0.0.1.jar /demo-0.0.1.jar
 ---> Using cache
 ---> 243662a30000
Step 3/3 : CMD ["java","-jar","/demo-0.0.1.jar"]
 ---> Using cache
 ---> 328d450440c1
Successfully built 328d450440c1
Successfully tagged java-demo:0.1
```

这个 Dockerfile 很简单，一共用到了 3 个指令：`FROM`、`COPY` 和 `CMD`。

我们接下来分别介绍 Dockerfile 的常用指令。

## FROM 指定基础镜像

所谓定制镜像，一定是以一个镜像为基础，在其上进行定制（添加镜像层）。

我们之前做容器健康检查时发现 Nginx 容器中没有 `curl` 命令，所需需要在其基础上添加 `curl` 工具：

```Dockerfile
FROM nginx:1.14.2

RUN apt-get update -y && apt-get install -y curl
```

`FROM` 指令就是指定基础镜像，因此一个 Dockerfile 中 `FROM` 是必备的指令，并且必须是第一个。

在 [Docker Hub](https://hub.docker.com/) 上有很多质量非常高的官方镜像：

- 有可以直接拿来使用的服务类镜像：[Nginx](https://hub.docker.com/_/nginx)、[Tomcat](https://hub.docker.com/_/tomcat/)、[Php](https://hub.docker.com/_/php/)、[Httpd](https://hub.docker.com/_/httpd/)、[Wordpress](https://hub.docker.com/_/wordpress)、[Server JRE](https://hub.docker.com/_/oracle-serverjre-8)、[MySQL](https://hub.docker.com/_/mysql)、[Redis](https://hub.docker.com/_/redis)、[MongoDB](https://hub.docker.com/_/mongo) 等；

- 还有一些方便开发、构建、运行各种语言应用的镜像：[Node](https://hub.docker.com/_/node)、[Openjdk](https://hub.docker.com/_/openjdk)、[Python](https://hub.docker.com/_/python)、[Golang](https://hub.docker.com/_/golang)、[Ruby](https://hub.docker.com/_/ruby) 等；

- 如果没有找到对应的服务镜像，官方还提供了一些更为基础的操作系统镜像可以在其基础上自制专属的服务镜像：[Ubuntu](https://hub.docker.com/_/ubuntu/)、[Debian](https://hub.docker.com/_/debian/)、[CentOS](https://hub.docker.com/_/centos/)、[Fedora](https://hub.docker.com/_/fedora/)、[Alpine](https://hub.docker.com/_/alpine/) 等。

- 甚至还有官方提供的空白镜像 [scratch](https://hub.docker.com/_/scratch)，这个镜像是虚拟的概念，它并不实际存在。如果你以 `scratch` 为基础镜像的话，意味着你不以任何镜像为基础，接下来的所写的指令将作为镜像第一层开始存在。<br/>对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的依赖库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。

对于使用官方镜像，必须要阅读官方镜像的说明，或者直接阅读官方镜像的 Dockerfile 能有助于我们更好的使用官方镜像。

比如说 MySQL 官方镜像提供了一些变量可以方便我们配置 MySQL 的 Root 密码：

> MYSQL_ROOT_PASSWORD
>
> This variable is mandatory and specifies the password that will be set for the MySQL root superuser account. In the above example, it was set to my-secret-pw.
> 
> ...

还告诉我们了 MySQL 数据存储的位置让我们能快速定位并使用数据卷或挂载数据目录：

> The -v /my/own/datadir:/var/lib/mysql part of the command mounts the /my/own/datadir directory from the underlying host system as /var/lib/mysql inside the container, where MySQL by default will write its data files.

并且告诉我们如何使用自定义文件、如何备份数据库等等。

官方镜像之所以质量高，其一是因为官方镜像很精简；其二是因为官方镜像会考虑到各种各样的情况来制定逻辑关系。所以我们使用官方镜像时一定要阅读官方镜像的说明，避免重复造轮子。


## RUN 执行命令

`RUN` 指令就是用来执行命令的。其格式有两种：

- Shell 格式：`RUN <命令> 参数 1 参数 2`，就像直接在命令行中输入的命令一样。我们制作镜像时通常会采用这种形式：

  ```Dockerfile
  FROM nginx:1.14.2

  RUN apt-get update -y && apt-get install -y curl
  ```

- Exec 格式：`RUN ["可执行文件", "参数 1", "参数 2"]`，这更像是函数中调用的格式。

我们现在就可以在 Dockerfile 使用 `RUN` 从一个基础的操作系统镜像来制作一个带有 Redis 服务的镜像了：

```Dockerfile
FROM debian:stretch

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
```

这样制作出来的镜像是可以使用的，但是这种做法是很愚蠢的。

我们之前提到过镜像是分层的，最开始也提到了 Dockerfile 中每一个指令都会建立一层镜像层。所以每个 `RUN` 指令都会新建立一层镜像层。上面的这种写法，创建了 7 层镜像层，这样做是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多刚开始写 Dockerfile 的人常犯的一个错误。

因此上面的 Dockerfile 正确的写法应该是这样：

```Dockerfile
FROM debian:stretch

RUN buildDeps='gcc libc6-dev make wget' \
    && apt-get update \
# 安装依赖包
    && apt-get install -y $buildDeps \
# 下载 Redis 程序并进行解压编译安装
    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
    && mkdir -p /usr/src/redis \
    && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    && make -C /usr/src/redis \
    && make -C /usr/src/redis install \
# 安装完成后清理安装文件
    && rm -rf /var/lib/apt/lists/* \
    && rm redis.tar.gz \
    && rm -r /usr/src/redis \
    && apt-get purge -y --auto-remove $buildDeps
```

Dockerfile 支持 Shell 类的行尾添加 `\` 的命令行换行方式，以及行首 `#` 进行注释的格式。 `&&` 表示前面的命令执行成功后才会执行后面的命令，可以将多个命令串联起来（`||` 是将多个命令并联起来，表示前面的命令执行失败才会执行后面的命令）。这样良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易。

这样做还有以下好处：

1. 首先，之前所有的命令只有一个目的：就是编译、安装 Redis 可执行文件。因为没有必要建立很多层，只需要一层就足够。因此仅仅使用一个 `RUN` 指令来完成这部分所有的任务，将之前的 7 层简化为了 1 层。

2. 此外这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。很多人刚开始写 Dockerfile 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。

所以，我们在撰写 Dockerfile 的时候，要经常提醒自己，**这并不是在写 Shell 脚本，而是在定义每一层该如何构建**。

## COPY 复制文件或目录

`COPY` 指令将从构建上下文目录中的文件或目录复制到新的一层镜像层内的目标位置。和 `RUN` 指令一样，也有两种格式：

- Shell 格式： `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`；

- Exec 格式： `COPY [--chown=<user>:<group>] ["<源路径>",... "<目标路径>"]`。

比如我们之前制作的 Java Demo 镜像的 Dockerfile：

```Dockerfile
FROM java:8

COPY demo-0.0.1.jar /demo-0.0.1.jar

ENTRYPOINT ["java","-jar","/demo-0.0.1.jar"]
```

**<源路径>**可以是多个，甚至可以是通配符，其通配符规则要满足 Go 语言的 [filepath.Match](https://golang.org/pkg/path/filepath/#Match) 规则：

```Dockerfile
COPY hom* /mydir/
COPY hom?.txt /mydir/
```

**<目标路径>**可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。

此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。

在使用该指令的时候还可以加上 `--chown=<user>:<group>` 参数来改变文件或目录的所属用户及所属组。


## ADD 复杂化的复制文件或目录

`ADD` 指令和 `COPY` 的格式基本一致：

- Shell 格式： `ADD [--chown=<user>:<group>] <源路径>... <目标路径>`；

- Exec 格式： `ADD [--chown=<user>:<group>] ["<源路径>",... "<目标路径>"]`。

只是 `ADD` 指令在 `COPY` 指令基础上增加了一些功能：

- **好用的功能**：如果 `<源路径>` 为一个 tar 压缩文件的话，压缩格式为 `gzip`、`bzip2`以及 `xz` 的情况下，`ADD` 指令将会自动解压缩这么压缩文件到 `<目标路径>` 中。某些情况下，这个自动解压缩的功能非常好用，比如说 [CentOS 官方镜像](https://github.com/CentOS/sig-cloud-instance-images/blob/a77b36c6c55559b0db5bf9e74e61d32ea709a179/docker/Dockerfile)：

  ```bash
  FROM scratch
  ADD centos-7-docker.tar.xz /
  ...
  ```

  如果你不希望解压压缩包，就不要在 `<目标路径>` 的结尾加上 `/`，这样 Docker 会把 `<目标路径>` 当做一个文件。

  ```bash
  FROM java:8

  ADD demo-0.0.1.jar /demo-0.0.1.jar

  ENTRYPOINT ["java","-jar","/demo-0.0.1.jar"]  
  ```

- **不好用的功能**：如果 `<源路径>` 为一个 URL，Docker 引擎会试图下载这个 URL 连接的文件放到 `<目标路径>` 中。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，还需要增加额外的一层 `RUN` 进行权限调整；另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN` 指令进行解压缩。<br/>所以不如直接用 `RUN` 指令，然后使用 `wget` 或者 `curl` 工具下载、处理权限、解压缩，然后清理无用文件更合理。因此，这是个非常愚蠢的功能，不推荐使用。

总之，尽可能的使用 `COPY`，因为 `COPY` 的语义非常明确，只是复制文件或目录而已。而 `ADD`，包含了更复杂的功能，其行为不是很清晰。所以，只有在需要自动解压缩的情况下去使用 `ADD` 指令。

## CMD 启动命令

`CMD` 指令指令有三种格式：

- Exec 格式：`CMD ["可执行文件","参数 1", "参数 2"]`，首选格式。

- Exec 参数格式: `CMD ["参数 1", "参数 2"]`，这种格式作为 `ENTRYPOINT` 的默认参数。

- Shell 格式： `CMD 命令 参数1 参数2`。

我们反复说过，Docker 容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD` 指令就是用于指定默认的容器主进程的启动命令的。


**第一种格式**最为常见，也是官方推荐的使用格式。这类格式在解析时会被解析为 Json 数组，因此一定要使用双引号，而不要使用单引号。

我们来看 CentOS 7 的官方镜像的 Dockerfile:

```Dockerfile
FROM scratch
ADD centos-7-docker.tar.xz /

LABEL org.label-schema.schema-version="1.0" \
    org.label-schema.name="CentOS Base Image" \
    org.label-schema.vendor="CentOS" \
    org.label-schema.license="GPLv2" \
    org.label-schema.build-date="20181205"

CMD ["/bin/bash"]
```

根据这个镜像启动的默认容器主进程是 `/bin/bash`，我们来进行验证：

```bash
$ docker container run --rm -it centos:7
  PID TTY          TIME CMD
    1 pts/0    00:00:00 bash
```

所以我们默认启动 CentOS 容器会进入到一个可执行 Bash 环境下。

在运行容器的时候，可以指定新的命令来代替镜像中设置的这个默认命令，比如：

```bash
$ docker container run --rm -it centos:7 cat /etc/centos-release
CentOS Linux release 7.6.1810 (Core)
```

我们用 `cat /etc/centos-release` 替换了默认的 `/bin/bash` 命令，输出了系统版本信息。

**第二种格式**在某些情况下会使用到，比如说我们制作一些工具镜像。


我们来看之前制作过的 Stress 压测工具镜像：

```Dockerfile
FROM centos:7

RUN yum install -y epel-release && yum install -y stress

ENTRYPOINT ["/usr/bin/stress"]
CMD ["--help"]
```

这种方式 `CMD` 指令作为 `ENTRYPOINT` 指令的参数使用，我们默认启动这个容器时会提示帮助信息：

```bash
$ docker container run --rm -it stress:0.1
`stress' imposes certain types of compute stress on your system

Usage: stress [OPTION [ARG]] ...
 -?, --help         show this help statement
     --version      show version statement
 -v, --verbose      be verbose
...
```

而且我们在运行这个容器时也可以指定参数来覆盖默认的 `--help` 参数。

我们制作 Java 镜像时也可以这样来指定运行的命令：

```Dockerfile
FROM java:8

COPY demo-0.0.1.jar /demo-0.0.1.jar

ENTRYPOINT ["java"]
CMD ["-jar", "/demo-0.0.1.jar"]
```

但这种情况不适合使用这种格式，至于什么时候该结合使用 `ENTRYPOINT` 指令与 `CMD` 指令，我们讲 `ENTRYPOINT` 指令时再介绍。

**第三种格式**在某些情况下很好用，比如说在使用到环境变量时。

比如说我们制作一个 CentOS 的镜像的 Dockerfile 如下：

```Dockerfile
FROM centos:7

CMD ["echo","$HOME"]
```

我们用这个镜像启动容器时的输出为：

```bash
$ docker container run -it --rm centos:test
$HOME
```

如果 Dockerfile 如下：

```bash
FROM centos:7

CMD echo $HOME
```

这时就会得到我们期望的输出结果：

```bash
$ docker container run -it --rm centos:test
/root
```

这是因为，如果使用 Shell 格式的话，实际的命令会被包装为 `sh -c` 的参数形式执行。

上面的例子中：

```Dockerfile
CMD echo $HOME
```

在实际执行中，会将其更改为：

```Dockerfile
CMD ["sh", "-c", "echo $HOME"]
```

这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。

如果不想使用 Shell 格式但想进行一些依赖 Shell(输出变量等）的操作，记得加上 `CMD ["sh", "-c", "参数..."]`。

**有一个初学者很容易出现的一个误区**：在容器内使用 `Upstart` 或 `Systemd` 或直接以后台启动的形式去启动后台服务。

比如说：

```Dockerfile
CMD service nginx start
```

或 

```Dockerfile
CMD systemctl start nginx
```

或 

```Dockerfile
# Nginx 默认是以后台方式启动的
CMD ["nginx"]
```

然后启动容器时执行命令后就立即退出了：

```bash
# Nginx 容器 FROM 的基础镜像为 Debian，Debian 系统使用 Upstart 来管理服务
$ docker container run --rm -it nginx:1.14.2 service nginx start
```

```bash
$ docker container run --rm -it nginx:1.14.2 nginx
```

如果使用 `systemctl`，发现连命令都执行不了：

```bash
# 我自己用 CentOS 镜像做为基础镜像制作了一个 Nginx 镜像，CentOS 7 以上使用 Systemd 来管理服务
$ docker container run --rm -it nginx:test systemctl start nginx
Failed to get D-Bus connection: Operation not permitted
```

如果你使用了这种写法，是因为你还是没区分容器和虚拟机的差别。依旧在用传统虚拟机的角度去理解容器。

再说一遍，容器只是进程而已。**对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其子进程不是它所关心的东西**。

> **容器进程管理**
>
> 容器内的主进程就是容器内的 1 号进程（Pid 为 1），虽然在宿主机看来就是个普通进程（PPid 为 1），但在容器内却扮演着超级进程的角色。也就是说容器内其他所有的进程都是容器内主进程（Pid 为 1）的子进程（PPid 为 1），都是被容器内的主进程所管理的。
>
> 如果你启动的容器内有多个进程但是主进程没有管理能力（发送或接受信号、回收僵尸进程等能力），这个容器的设计是失败的。
>
> 这也是为什么推荐一个容器一个进程(One Process Per Container)的原因。

而使用了 `service nginx start` 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 `CMD service nginx start` 会被理解为 `CMD [ "sh", "-c", "service nginx start"]`，因此主进程实际上是 `sh -c service nginx start`。那么当 `service nginx start` 命令结束后，`sh` 也就退出了，`sh -c service nginx start` 这个主进程自然也会退出。作为主进程退出了，自然就会令容器退出。

这也是为什么 `CMD` 指令不推荐使用 Shell 格式的原因，因为用户往往会忽略了 `sh -c` 这个补充的命令。

而使用了 Exec 格式直接执行 `nginx` 命令，执行完毕后会运行 Nginx 后台程序，执行的命令 `nginx` 也会退出，从而导致主进程退出，令容器也退出了。

所以正确的写法是：**让容器的主进程始终保持前台运行，使程序一直执行**：

```Dockerfile
CMD ["nginx", "-g", "daemon off;"]
```

或

```Dockerfile
CMD ["java", "-jar", "demo.jar"]
```

如何判断你的进程是否是前台运行：最好的标志就是你运行程序后输入回车不会退回到终端。

总之，**就是一定要保证你的容器的启动命令一直执行，不会退回到终端**。


**还有一种自作聪明的写法**：添加类似于 `tail`、`top` 这种可以前台运行的程序保持持续输出，使你的主程序不会退出。网上有不少类似的写法，很蠢。

比如说：

```bash
CMD service nginx && tail -f /var/log/nginx/access.log
```

使用了这种写法的确能达到在容器内后台启动进程而不退出的效果，我们来模拟这种写法：

```bash
# 挂载这两个文件只是为了使用 ps 命令查看进程，Nginx 官方镜像中不带 ps 命令
$ docker container run -d \
    --mount type=bind,src=/usr/bin/ps,dst=/usr/bin/ps \
    --mount type=bind,src=/usr/lib64/libprocps.so.4,dst=/usr/lib/libprocps.so.4 \
    --name nginx \
    nginx:1.14.2 sh -c "service nginx start && tail -f /var/log/nginx/access.log"
```

我们查看容器的状态是正常的，容器的启动命令为 `sh -c 'service nginx start && tail -f /var/log/nginx/access.log'`：

```bash
$ docker container ls --no-trunc
...     command     ...                                                         STATUS          PORTS       NAMES
...     "sh -c 'service nginx start && tail -f /var/log/nginx/access.log'"      Up 2 minute     80/tcp      nginx
```

我们来查看容器内的主进程（Pid 为 1）：

```bash
$ docker container exec nginx ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 18:08 ?        00:00:00 sh -c service nginx start && tail -f /var/log/nginx/access.log
root        13     1  0 18:08 ?        00:00:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf
nginx       14    13  0 18:08 ?        00:00:00 nginx: worker process
root        15     1  0 18:08 ?        00:00:00 tail -f /var/log/nginx/access.log
root        16     0  0 18:30 ?        00:00:00 ps -ef
```

主进程依靠 `tail -f /var/log/nginx/acess.log` 一直在运行所以没有退出，所以容器没有退出。

这么做蠢在哪：Nginx 进程变成了「孤儿进程」，因为主进程没有管理子进程的能力。

> **孤儿进程与僵尸进程管理**
>
> 当一个子进程终止后，它首先会变成一个「失效（Defunct）」的进程，也称为「僵尸（zombie）」进程，等待父进程或系统收回（Reap）。在 Linux 内核中维护了关于「僵尸」进程的一组信息（PID，终止状态，资源使用信息），从而允许父进程能够获取有关子进程的信息。如果不能正确回收「僵尸」进程，那么他们的进程描述符仍然保存在系统中，系统资源会缓慢泄露。
>
> 大多数设计良好的多进程应用可以正确的收回僵尸子进程，比如 NGINX Master 进程可以收回已终止的 Worker 子进程。
>
> 如果父进程已经结束了，那些依然在运行中的子进程会成为「孤儿（Orphaned）」进程。

我们来杀掉容器内的 Nginx 进程：

```bash
$ docker container exec nginx sh -c "kill -9 13 14"

$ docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b63b4e7b2d1d        nginx:1.14.2        "sh -c 'service ngin…"   3 minutes ago       Up 3 minutes        80/tcp              nginx

$ docker container exec nginx ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 18:50 ?        00:00:00 sh -c service nginx start && tail -f /var/log/nginx/access.log
root        15     1  0 18:50 ?        00:00:00 tail -f /var/log/nginx/access.log
root        27     0  0 18:54 ?        00:00:00 ps -ef
```

结束了 Nginx 进程后，容器状态正常，但是服务却不可用了。

即使可以使用健康检查机制可以判断容器内服务的状态，但是还是不推荐这么做，因为一个 Nginx 容器，它的主进程就应该是 Nginx 服务，Nginx 服务挂掉，容器就应该被关闭。

所以，我们还需要记住一点：**一个容器内的主进程不应该是 Shell 环境（比如说 `/bin/bash`、`/bin/sh`），如果你这么做，你就把容器当成虚拟机来使用了。容器内的主进程应该就是服务前台启动模式的一直运行中的进程，而不是依赖其他的进程保持看似一直运行中的「假象」。**

